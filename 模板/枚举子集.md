
# 枚举子集


## 利用二进制枚举子集
  **二进制枚举n的全部子集**
```C++
void SubSet(int n) {

    for(int S = 0; S < (1 << n); S++) {
        //S是n的一个子集
        for(int i = 0; i < n; i ++) {
            int x = (S>>i)&1; // 输出第i个元素
            cout << x;
        }
        cout << endl;

    }

}
```
  **二进制枚举某一集合的子集**
* 某个集合`sup`的子集， 假设`sup = 01101101`, 要枚举出`0110000`或`00101101`这样的子集， 正着枚举可能会出现重复，因为可能`(sub+1)&sub`可能依旧是`sub`, 这时应该反向枚举。

```C++
int sub = sup;
do {

    //对子集的处理
    sub = (sub - 1) & sup;
} while(sub != sup); //处理完0后， 会有 -1&sup = sup
```

**枚举大小为`K`的子集**

* 求出最低位的`1`开始的连续的`1`的区间`(0101110->0001110)`
* 将这一区间全部变为`0`，并将区间左侧的那个`0`变为`1`，`(0101110->0110000)`
* 将第一步里取出的区间右移， 直到的`1`的个数少一个`(0001110->0000011)`
* 将第二步和第三步的结果按位取或`(0110000|0000011=0110011)`

```C++
int comb = (1 << k) - 1;    // 字典序最小的
while( comb < (1<<n) ) {
    // 对组合comb进行处理
    int x = comb & -comb;   // 取出最低位的1
    int y = comb + x;       // 从最低位的1开始的连续的1全部置零
    comb = ( (comb & ~y) )  // comb 现在是最低位连续的1
    comb /= x;              // comb 右移到最低位为1
    comb >> 1;              // 去掉最低位的1
    comb = comb | y;        // 得到答案
}

 
```